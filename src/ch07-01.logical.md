# 逻辑运算

逻辑运算，即与and、或or、非not。其中最后一个非not是一元运算，很简单，已经在之前[一元运算](./ch05-01.unary_ops.md)中介绍过了。本章只介绍前面两个与and和或or。这可能是整个解释器中最绕的一部分。

**短路**。那为什么没有在之前的二元运算小节中介绍与and和或or呢？因为“短路”！应该大部分主流编程语言（比如C、Rust）中，逻辑运算都是短路的。比如对于与and运算，如果第一个操作数是false，那么就没必要（也不能）求第二个操作数了。比如语句`is_valid() and count()`，假如`is_valid()`的返回值是false，那么就不能执行后续的`count()`。所以，逻辑运算的执行过程是：1.先判断左操作数，2.如果是false则退出，3.否则判断右操作数。而之前介绍二元数值运算的执行过程是：1.先求左操作数，2.再求右操作数，3.最后计算。所以，逻辑运算跟数值运算不同，不能套用之前的做法。

**求值结果**。Lua中的逻辑运算跟C、Rust中的也有不同之处，就是运算结果并不一定是布尔值。比如在C语言中如下语句：

```c
	int i=10, j=11;
	printf("%d\n", i && j);  // 输出：1
```

会输出`1`，因为`&&`运算符会先把两个操作数转换为布尔类型（这个例子里都是true），然后再执行`&&`运算，结果是true，在C语言里就是1。而Rust语言更严格，强制要求`&&`的两个操作数都必须是布尔类型，那么结果自然也是布尔类型。但是Lua中的逻辑运算的求值结果是最后一个判断的操作数。比如下面都是很常见的用法：

- `print(t and t.k)`，先判断t是否存在，再对t求索引。如果t不存在那么就不用判断t.k了，所以结果就是t即nil；否则就是t.k。
- `print(t.k or 100)`，索引表并提供默认值。先判断t中是否有k，如果有那么就不用判断100了，所以结果就是t.k；否则就是100。
- `print(v>0 and v or -v)`，求绝对值。如果是正数则结果是v，否则就是-v。模拟C语言中的`?:`三元运算符。

**使用场景**。逻辑运算有两个使用场景：

1. 作为判断条件，比如上一章中if、while等语句中的判断条件语句，比如`if t and t.k then ...`；
2. 求值，比如`print(v>0 and v or -v)`。

其实第1种场景可以看做是第2种场景的简化版，不需要具体求值，只需要判断真假（回归到C、Rust中逻辑运算的语义）。比如上述的if语句例子，可以认为是先对`t and t.k`求值到临时变量，然后再判断临时变量是否为真，来决定是否跳转。这里我们并不关心具体的求值结果是`t`还是`t.k`，而只关心true或者false，所以可以省去临时变量！由于逻辑运算大部分应用是第1种场景，所以特地做优化，省去临时变量，直接根据求值结果来判断是否跳转。

下面先介绍第1种场景。然后？？下一节？再介绍第2种场景。

## 归纳

介绍完准备知识，在开始解析前，还需要学习具体的跳转规律。

上面介绍了逻辑运算的短路特性，所以在每次判断完一个操作数后，都可能发生跳转，跳过下一个操作数。但具体如何跳转？非常绕。下面用最简单的if语句做例子，尝试归纳跳转规律：

```
 A and B                      X or Y

+-------+                    +-------+
|   A   +-False-\    /--True-+   X   |
+---+---+       |    |       +---+---+
    |True       |    |           |False
    V           |    |           V
+-------+       |    |       +-------+
|   B   +-False>+    |       |   Y   +-False-\
+---+---+       |    |       +---+---+      |
    |True       |    \---------->|True      |
    V           |                V          |
  block         |              block        |
    |           |                |          |
    +<----------/                +<--------/
    V                            V
```

左图是与and运算。两个操作数A和B判断后的处理一样，都是True则继续执行；False则跳转到代码块结尾。

右图是或or运算。第二个操作数Y的处理跟之前A、B的处理方式一样，但第一个操作数X的有变：False则继续执行，True则跳转到代码块开始。

不过只看这两个总结不出规律。还需要看些复杂的：

```
A and B and C               X or Y or Z                 (A and B) or Y               A and (X or Y)

+-------+                    +-------+                    +-------+                    +-------+
|   A   +-False-\    /--True-+   X   |                    |   A   |-False-\            |   A   +-False-\
+---+---+       |    |       +---+---+                    +---+---+       |            +---+---+       |
    |True       |    |           |False                       |True       |                |True       |
    V           |    |           V                            V           |                V           |
+-------+       |    |       +-------+                    +-------+       |            +-------+       |
|   B   +-False>+    +<-True-+   Y   |            /--True-+   B   |       |    /--True-+   X   |       |
+---+---+       |    |       +---+---+            |       +---+---+       |    |       +---+---+       |
    |True       |    |           |False           |      False|<---------/     |           |False      |
    V           |    |           V                |           V                |           V           |
+-------+       |    |       +-------+            |       +-------+            |       +-------+       |
|   C   +-False>+    |       |   Z   +-False-\    |       |   Y   +-False-\    |       |   Y   +-False>+
+---+---+       |    |       +---+---+       |    |       +---+---+       |    |       +---+---+       |
    |True       |    \---------->|True       |    \---------->|True       |    \---------->|True       |
    V           |                V           |                V           |                V           |
  block         |              block         |              block         |              block         |
    |           |                |           |                |           |                |           |
    +<---------/                 +<----------/                +<---------/                 +<---------/
    V                            V                            V                            V
```

根据这4个图可以归纳如下规律（其实可能需要更多的情况才更好归纳，但是画图太麻烦了）：

- 跳转条件取决于语句后面的逻辑运算符：
  + 如果后面跟`and`运算，则False跳转而True继续执行。比如第1个图中的A和B，后面都是and运算，所以都是False跳转。

  + 如果后面跟`or`运算，则True跳转而False继续执行。比如第2个图中的X和Z，后面都是or运算，所以都是True跳转。

  + 整条判断语句结束，则False跳转而True继续执行。上面4个图最后一个判断语句都是如此。

- 跳转位置规则：
  + 如果连续相同的跳转条件，则跳转到同样位置。比如第1个图中连续3个False跳转，第2个图中连续2个True跳转；而第3个图中的两个False跳转并不连续，所以跳转位置不同。所以遇到相同的跳转条件，就合并跳转列表。
  
  + 如果遇到不同的跳转条件，则终结前面的跳转列表，并跳转到当前判断语句之后。比如第2个图中Z的False终结前面的两个True的跳转列表，并跳转到Z语句后面；再比如第3个图中B的True终结之前的False跳转列表，并跳转到B语句后面。
  
  + 不过第4个图貌似没有遵守上述两条规则，两个False跳转并不连续但也连起来了，或者说X的True跳转并没有终结A的False跳转列表。这是因为A并不是跟`X`运算，而是跟`(X or Y)`运算；要先求`(X or Y)`，此时X的True跳转是全新的，并不知道前面的A的False跳转列表；然后再求`A and (X or Y)`时，就是True和False两个跳转列表并存了；最终语句结束的False，合并之前A的False跳转列表，并终结X的True跳转列表。

  + 判断语句的结束是False跳转，所以会终结True跳转列表，并继续False跳转列表。在block结束后，终结False跳转列表到block结尾。

至此，介绍完准备知识。下面开始编码实现。

## 字节码

上一章控制结构的几个条件判断语句，包括if、while、和repeat..until等，对判断条件的处理都是False跳转，所以只有一个测试并跳转的字节码，即`Test`。而现在需要2种跳转，False跳转和True跳转。为此我们去掉之前的`Test`，并新增2个字节码：

```rust,ignore
pub enum ByteCode {
    TestAndJump(u8, i16),  // 如果Test为True，则Jump。
    TestOrJump(u8, i16),   // 如果Test为False，则Jump。跟上一章的`Test`功能相同。
```

命名中的“and”和“or”，跟本节介绍的逻辑运算并无关系，而是源自Rust语言中Option和Error类型的方法名，分别是“那么就”和“否则就”的意思。不过本节最开头的两个例子中，`t and t.k`可以描述为：如果t存在“那么就”取t.k，`t.k or 100`可以描述为：如果t.k存在就取其值“否则就”取100。也是相关联的。

只不过上面介绍的跳转规则第1条，如果后面跟`and`运算，则False跳转，对应的是`TestOrJump`。虽然没有匹配上，但是这个关系不大。

官方Lua实现中，仍然只是一条字节码`TEST`，关联两个参数分别是：判断条件的栈地址（跟我们的一样），和跳转条件（True跳转还是False跳转）。而具体的跳转位置，则需要再加一条无条件跳转的`JUMP`字节码。这么做是为了跟另外一个应用场景。TODO。。。

## ExpDesc

