# 参数

上一节介绍了Lua函数的定义和调用流程。这一节介绍函数的参数。

参数这个名词有两个概念：

- 形参，parameter，指函数原型中的参数，包括参数名和参数类型等信息；
- 实参，argument，指函数调用时的参数，是具体的值。

本节后面介绍语法分析和虚拟机执行时，都要明确区分形参和实参。

在Lua语言中，函数的参数就是局部变量！在语法分析时，形参也会放到局部变量表中起始位置，这样后续代码中如果有对形参的引用，也会在局部变量表中定位到。在虚拟机执行阶段，实参被加载到栈上紧跟函数入口的位置，后面再跟局部变量，与语法分析阶段局部变量表中的顺序一致。比如对于如下函数：

```lua
local function foo(a, b)
    local x, y = 1, 2
end
```

在执行`foo()`函数时，栈布局如下（栈右边的数字0-3是相对索引）：

```
|     |
+-----+
| foo |
+=====+ <---base
|  a  | 0  \
+-----+     + 参数
|  b  | 1  /
+-----+
|  x  | 2  \
+-----+     + 局部变量
|  y  | 3  /
+-----+
|     |
```

参数和局部变量唯一的区别就是，参数的值是在调用时由调用者传入的，而局部变量是在函数内部赋值的。

## 形参的语法分析

形参的语法分析，也就是函数定义的语法分析。上一节介绍函数定义时，语法分析的过程省略了参数部分，现在加上。函数定义的BNF是funcbody，其定义如下：

```
   funcbody ::= `(` [parlist] `)` block end
   parlist ::= namelist [`,` `...`] | `...`
   namelist ::= Name {`,` Name}
```

由此可以看到，形参列表由两个可选的部分组成：

- 可选的多个Name，是固定参数。上一节在解析新函数，创建`FuncProto`结构时，局部变量表`locals`字段被初始化为空列表。现在要改为初始化为形参列表。这样形参就在局部变量表的最前面，后续新建的局部变量跟在后面，与本节开头的栈布局图一致。另外，由于Lua语言中调用函数的实参个数允许跟形参个数不等。多则舍去，少则补nil。所以`FuncProto`结果中也要增加形参的个数，用以在虚拟机执行时做比较。

- 最后一个可选的`...`，表明这个函数支持可变参数。如果支持，那么在后续的语法分析中，函数体内就可以使用`...`来引用可变参数，并且在虚拟机执行阶段，也要对可变参数做特殊处理。所以在`FuncProto`中需要增加一个标志位，表明这个函数是否支持可变参数。

综上，一共有三个改造点。在`FuncProto`中增加两个字段：

```rust,ignore
pub struct FuncProto {
    pub has_varargs: bool,  // 是否支持可变参数。语法分析和虚拟机执行中都要使用。
    pub nparam: usize, // 固定参数个数。虚拟机执行中使用。
    pub constants: Vec<Value>,
    pub byte_codes: Vec<ByteCode>,
}
```

另外在初始化`ParseProto`结构时，用形参列表来初始化局部变量`locals`字段。代码如下：

```rust,ignore
impl<'a, R: Read> ParseProto<'a, R> {
    // 新增has_varargs和params两个参数
    fn new(lex: &'a mut Lex<R>, has_varargs: bool, params: Vec<String>) -> Self {
        ParseProto {
            fp: FuncProto {
                has_varargs: has_varargs,  // 是否支持可变参数
                nparam: params.len(),  // 形参个数
                constants: Vec::new(),
                byte_codes: Vec::new(),
            },
            sp: 0,
            locals: params,  // 用形参列表初始化locals字段
            break_blocks: Vec::new(),
            continue_blocks: Vec::new(),
            gotos: Vec::new(),
            labels: Vec::new(),
            lex: lex,
        }
    }
```

至此，完成形参的语法分析。其中涉及到可变参数、虚拟机执行等部分，下面再详细介绍。

## 实参的语法分析

实参的语法分析，也就是函数调用的语法分析。这个在之前章节实现prefixexp的时候已经实现过了：通过`explist()`函数读取参数列表，并依次加载到栈上函数入口的后面位置。与本节开头的栈布局图一致，相当于是给形参赋值。这里解析到实际的参数个数，并写入到字节码`Call`的参数中，用于在虚拟机执行阶段跟形参做比较。

但当时的实现并不完整，还不支持可变参数。本节后面再详细介绍。

## 虚拟机执行

上面的实参语法分析中，已经把实参加载到栈上，相当于是给形参赋值，所以虚拟机执行函数调用时，本来就无需再处理参数了。但是在Lua语言中，函数调用时实参个数可能不等于形参个数。如果实参多于形参，那无需处理，就认为多出的部分是个占据栈位置但无用的临时变量；但如果实参少于形参，那么需要对不足的部分设置为nil，否则后续字节码对这个形参的引用就会导致Lua的栈访问异常。除此之外，`Call`字节码的执行就不需要对参数做其他处理。

上面语法分析时已经介绍过，形参和实参的个数，分别在`FuncProto`结构中的`nparam`字段和`Call`字节码的关联参数中。所以函数调用的虚拟机执行代码如下：

```rust,ignore
    ByteCode::Call(func, narg) => {  // narg是实际传入的实参个数
        self.base += func as usize + 1;
        match &self.stack[self.base - 1] {
            Value::LuaFunction(f) => {
                let narg = narg as usize;
                let f = f.clone();
                if narg < f.nparam {  // f.nparam是函数定义中的形参个数
                    self.fill_stack(narg, f.nparam - narg);  // 填nil
                }
                self.execute(&f);
            }
```

至此，完成了固定参数的部分，还是比较简单的；下面介绍可变参数部分，开始变得复杂起来。

## 可变参数

在上面[形参的语法分析](#形参的语法分析)中已经提到了可变参数，其功能比较简单，代表这个函数支持可变参数。本节接下来主要介绍可变参数作为实参的处理，也就是执行函数调用时实际传入的参数。

本节最开始就介绍函数的参数就是局部变量，并画了栈的布局图。不过这个说法只适合固定的实参，而对于可变实参就不适合了。在之前的`foo()`函数中加上可变参数作为示例，代码如下：

```lua
local function foo(a, b, ...)
    local x, y = 1, 2
    print(x, y, ...)
end
```

加上可变参数后，栈布局该变成什么样？或者说，可变实参要存在哪里？比如调用函数的语句是`foo(1, 2, 3, 4, 5)`，其中`1`和`2`分别对应形参`a`和`b`，而后面的`3`、`4`和`5`就是可变实参。在调用开始前，栈布局如下：

```
|     |
+-----+
| foo |
+-----+
|  1  |  \
+-----+   + 固定实参，对应a和b
|  2  |  /
+-----+
|  3  |  \
+-----+   |
|  4  |   + 可变实参，对应...
+-----+   |
|  5  |  /
+-----+
|     |
```

那进入到`foo()`函数后，后面的三个实参要存在哪里？最直接的想法是保持上面的布局不变，也就是可变实参存到固定实参的后面。但是，这样是不行的！因为这样就会挤占局部变量的空间，即示例里的`x`和`y`就要后移，后移的距离是可变实参的个数。但是在语法分析阶段是不能确定可变实参的个数的，就无法确定局部变量在栈上的位置，就无法访问局部变量了。

Lua官方的实现是，在语法分析阶段忽略可变参数，让局部变量仍然在固定参数的后面。但是在虚拟机执行时，在进入到函数中后，把可变参数挪到函数入口的前面，并且记录可变实参的个数。这样后续在访问可变参数时，根据函数入口位置和可变实参的个数，就可以定位栈位置，即`stack[self.base - 1 - 实参个数 .. self.base - 1]`。下面是栈布局图：

```
|     |
+-----+
|  3  | -4 \
+-----+     |                          num_varargs: usize  // 记录下可变实参的个数
|  4  | -3  + 相对于上图，                    +-----+
+-----+     | 把可变实参挪到函数入口前面        |  3   |
|  5  | -2 /                                +-----+
+-----+
| foo | <-- 函数入口
+=====+ <-- base
| a=1 | 0  \
+-----+     + 固定实参，对应a和b
| b=2 | 1  /
+-----+
|  x  | 2  \
+-----+     + 局部变量
|  y  | 3  /  仍然紧跟固定参数后面
```

既然这个方案需要在虚拟机执行时需要记录额外信息（可变实参的个数），并且还要移动栈上参数，那么更简单的做法是直接记录可变实参：

```
|     |
+-----+
| foo | <-- 函数入口                  varargs: Vec<Value>  // 直接记录可变实参
+=====+                                 +-----+-----+-----+
| a=1 | 0  \                            |  3  |  4  |  5  |
+-----+     + 固定实参，对应a和b           +-----+-----+-----+
| b=2 | 1  /
+-----+
|  x  | 2  \
+-----+     + 局部变量
|  y  | 3  /
```

相比于Lua的官方实现，这个方法没有利用栈，而是使用Vec，会有额外的堆上内存分配。但是更加直观清晰。

确定下可变实参的存储方式后，就可以进行语法分析和虚拟机执行了。

## ExpDesc::VarArgs和应用场景

可变实参是一个独立的表达式，在`exp_limit()`函数中解析，并新增一种表达式类型`ExpDesc::VarArgs`，这个类型没有关联参数。

读取这个表达式很简单，先检查当前函数是否支持可变参数（函数原型中有没有`...`），然后返回`ExpDesc::VarArgs`即可。具体代码如下：

```rust,ignore
    fn exp_limit(&mut self, limit: i32) -> ExpDesc {
        let mut desc = match self.lex.next() {
            Token::Dots => {
                if !self.fp.has_varargs {  // 检查当前函数是否支持可变参数？
                    panic!("no varargs");
                }
                ExpDesc::VarArgs  // 新增表达式类型
            }
```

但是读到的`ExpDesc::VarArgs`如何处理？这就要先梳理使用可变实参的3种场景：

1. 当`...`作为函数调用的最后一个参数、return语句的最后一个参数、表构造的最后一个列表成员时，代表实际传入的全部实参；

2. 当`...`作为局部变量定义语句、或赋值语句的等号`=`后面最后一个表达式时，会按需求扩展或缩减个数；

3. 其他地方都只代表实际传入的第一个实参。

比如下面的示例代码：

```lua
function foo(a, b, ...)  -- 代表foo()函数支持可变参数
    -- 第1种场景：取全部可变实参
    print("hello: ", ...)  -- 最后一个实参
    local t = {1, 2, ...}  -- 最后一个列表成员
    if a then
        return a+b, ...  -- 最后一个返回值
    end

    -- 第2种场景：取前N个可变实参
    local x, y = ...   -- 取前2个实参，分别赋值给x和y
    t.k, t.j = a, ...  -- 取前1个实参，赋值给t.j

    -- 第3种场景：取第1个可变实参
    local x, y = ..., b  -- 不是最后一个表达式，只取第1个实参并赋值给x
    t.k, t.j = ..., b    -- 不是最后一个表达式，只取第1个实参并赋值给t.k
    if ... then  -- 条件判断
       t[...] = ... + f  -- 表索引，和二元运算操作数
    end
end
```

下面对上述3种场景依次分析。

## 场景1：全部可变实参

先介绍第1种场景，即加载全部可变实参。这个场景中3个语句的实现思路类似，都是在解析表达式列表的时候，只discharge前面的表达式，而保留最后一个表达式不discharge；然后在解析完整个语句后，单独检查最后一个语句是否为`ExpDesc::VarArgs`：

- 如果不是，则正常discharge。这种情况下，在语法分析时就能确定所有表达式的数量，而这个数量就可以编码进对应的字节码中。

- 如果是，则用新增的字节码`VarArgs`加载全部可变参数，而实际参数的个数在语法分析时不知道，要在虚拟机执行时才能知道，所以总的表达式的数量也不知道，也就无法编码到对应的字节码中，就需要用特殊值或新字节码来处理。

这个场景中的3个语句如下：

1. 函数调用的最后一个参数，是把当前函数的可变实参作为调用函数的可变实参，涉及两个可变实参，有点绕，不方便描述；

2. return语句的最后一个参数，但是现在还不支持返回值，要在下一节介绍；

3. 表构造的最后一个列表成员。

其中第3个语句相对而言最简单，所以先介绍表构造。

之前表构造的语法分析流程是：在循环读取全部成员过程中，如果解析到数组成员，则立即discharge到栈上；在循环读取完毕后，所有数组成员依次被加载到栈上，然后生成`SetList`字节码将其添加到表里。这个字节码的第2个关联参数就是成员数量。为了简单起见，这里忽略超过50个成员时分批加载的处理。

现在修改流程：为了单独处理最后一个表达式，在解析到数组成员时，要延迟discharge。具体做法比较简单但不容易描述，可以参见下面代码。代码摘自`table_constructor()`函数，只保留跟本节相关内容。

```rust,ignore
    // 新增这个变量，用来保存最后一个读到的数组成员
    let mut last_array_entry = None;

    // 循环读取全部成员
    loop {
        let entry = // 省略读取成员的代码
        match entry {
            TableEntry::Map((op, opk, key)) => // 省略字典成员部分的代码
            TableEntry::Array(desc) => {
                // 使用replace()函数，用新成员desc替换出上一个读到的成员
                // 并discharge。而新成员，也就是当前的“最后一个成员”，被
                // 存到last_array_entry中。
                if let Some(last) = last_array_entry.replace(desc) {
                    self.discharge(sp0, last);
                }
            }
        }
    }

    // 处理最后一个表达式，如果有的话
    if let Some(last) = last_array_entry {
        let num = if self.discharge_expand(last) {
            // 可变参数。在语法分析阶段无法得知具体的参数个数，所以用0来代表栈上全部
            0
        } else {
            // 计算出总的成员个数
            (self.sp - (table + 1)) as u8
        };
        self.fp.byte_codes.push(ByteCode::SetList(table as u8, num));
    }
```

上述代码整理流程比较简单，这里不一一介绍。在处理最后一个表达式时，有几个细节需要介绍：

- 新增的`discharge_expand()`方法，用以特殊处理`ExpDesc::VarArgs`类型表达式。可以预见这个函数后面还会被其他两个语句（return语句和函数调用语句）用到。其代码如下：

```rust,ignore
    fn discharge_expand(&mut self, desc: ExpDesc) -> bool {
        match desc {
            ExpDesc::VarArgs => {
                self.fp.byte_codes.push(ByteCode::VarArgs(self.sp as u8));
                true
            }
            _ => {
                self.discharge(self.sp, desc);
                false
            }
        }
    }
```

- 最后一个表达式如果是可变参数，那么`SetList`字节码的第2个关联参数则设置为`0`。之前（不支持可变数据表达式的时候）`SetList`字节码的这个参数不可能是0，因为如果没有数组成员，那不生成`SetList`字节码即可，而没必要生成一个关联参数是0的`SetList`。所以这里可以用`0`作为特殊值。相比而言，这个场景里的其他两个语句（return语句和函数调用语句）本来就支持0个表达式，即没有返回值和没有参数，那就不能用`0`作为特殊值了。到时候再想其他办法。

  当然这里也可以不用`0`这个特殊值，而是新增一个字节码，比如叫`SetListAll`，专门用来处理这种情况。这两种做法差不多，我们还是选择使用特殊值`0`。

- 虚拟机执行时，对于`SetList`第二个关联参数是`0`的情况，就取栈上表后面的全部的值。也就是从表的位置一直到栈顶，都是用来初始化的表达式。具体代码如下，增加对`0`的判断：

```rust,ignore
    ByteCode::SetList(table, n) => {
        let ivalue = self.base + table as usize + 1;
        if let Value::Table(table) = self.get_stack(table).clone() {
            let end = if n == 0 { // 0，可变参数，直至栈顶的全部表达式
                self.stack.len()
            } else {
                ivalue + n as usize
            };
            let values = self.stack.drain(ivalue .. end);
            table.borrow_mut().array.extend(values);
        } else {
            panic!("not table");
        }
    }
```

- 既然对于可变参数的情况，可以在虚拟机执行时根据栈顶来获取实际的表达式数量，那之前固定表达式的情况是不是也可以在执行时决定表达式数量，而不用在语法分析阶段就确定？这样一来`SetList`关联的第2个参数是不是就没用了？答案是否定的，因为栈上可能有临时变量！比如下面的代码：

```lua
t = { g1+g2 }
```

表达式`g1+g2`的两个操作数都是全局变量，在对整个表达式求值前，要都分别加载到栈上，需要占用2个临时变量的位置。栈布局如下：

```
|       |
+-------+
|   t   |
+-------+
| g1+g2 | 先把g1加载到这里。然后在求值g1+g2时，结果也加载到这里，覆盖原来的g1。
+-------+
|   g2  | 在求值g1+g2时，把全局变量g2加载到这里的临时位置
+-------+
|       |
```

此时栈顶是g2，如果也按照从表后直至栈顶的做法，那么g2也会被认为是表的一个成员。所以，对于之前的情况（固定数量的表达式）还是需要在语法分析阶段确定表达式的数量。

- 那么，为什么对于可变参数的情况就可以根据栈顶来确定表达式数量呢？这就要求虚拟机在执行加载可变参数的字节码时，清理掉临时变量。这一点非常重要。具体代码如下：

```rust,ignore
    ByteCode::VarArgs(dst) => {
        self.stack.truncate(self.base + dst as usize);  // 清理临时变量！！！
        self.stack.extend_from_slice(&varargs);  // 加载可变参数
    }
```

至此，完成了可变参数作为表构造最后一个表达式的语句的处理。相关代码并不多，但理清思路也不简单。

## 场景1：全部可变实参（续）

#### 从这里开始继续重写

上面介绍了第1种场景全部可变参数下的最简单的表构造语句，现在介绍可变参数作为函数调用的参数的情况。这两个语句对可变参数的处理方法差不多，这里只介绍下不同的地方。

本节上面介绍[实参的语法分析](#实参的语法分析)时已经说明，所有实参通过`explist()`函数依次加载到栈顶，并把实参个数写入到`Call`字节码中。但当时还不支持可变参数，现在加上。

这个场景稍微有一点绕。比如下面的示例：

```lua
function foo(a, b, ...)  -- 形参
    bar(a+b, ...)  -- 实参
end
```

首先第一行`foo()`后面的`...`是形参；第二行`bar()`后面的`...`是实参。这里讨论的是后者。并且，

如果参数列表的最后一个是`...`，即`ExpDesc::VarArgs`，那么实参的个数就无法在语法分析阶段确定，就不能把实参个数写入到`Call`字节码中。这就需要一个特殊值来代表可变参数的情况。然后在虚拟机执行期间，对于这种可变参数的情况，根据栈的情况来读取实际的实参个数。

先看语法分析阶段的处理，再看虚拟机执行阶段。语法分析时，参考官方Lua的实现，选择`0`来代表这种可变参数的情况，而对于固定实参的情况，就把实参个数加上1再写入到`Call`字节码中。比如没有实参就写`1`，有3个实参就写`4`。具体代码如下：

```rust,ignore
    fn args(&mut self) -> ExpDesc {
        let ifunc = self.sp - 1;
        let narg = match self.lex.next() {
            Token::ParL => {
                if self.lex.peek() != &Token::ParR {
                    // 读取实参列表。只保留和返回最后一个实参last_exp，而把前面的实参
                    // 依次加载到栈上并返回其个数nexp。
                    let (nexp, last_exp) = self.explist();

                    self.lex.expect(Token::ParR);

                    if last_exp == ExpDesc::VarArgs {
                        // 可变实参。生成新增的VarArgs字节码，读取全部可变实参！！
                        self.fp.byte_codes.push(ByteCode::VarArgs(self.sp as u8));
                        None
                    } else {  // 固定实参
                        self.discharge(self.sp, desc);
                        Some(nexp + 1)
                    }
                } else {  // 没有参数
                    self.lex.next();
                    Some(0)
                }
            }
            Token::CurlyL => {  // 不带括号的表构造
                self.table_constructor();
                Some(1)
            }
            Token::String(s) => {  // 不带括号的字符串常量
                self.discharge(ifunc+1, ExpDesc::String(s));
                Some(1)
            }
            t => panic!("invalid args {t:?}"),
        };

        // 对于n个固定实参，转换为n+1；
        // 对于可变实参，转换为0。
        let narg_plus = if let Some(n) = narg { n + 1 } else { 0 };

        ExpDesc::Call(ifunc, narg_plus)
    }
```

上述代码有几个地方需要说明。首先`explist()`方法，原来的行为是把所有表达式列表都加载到栈上，现在修改为保留并返回最后一个表达式，而只把前面的表达式加载到栈上。这样就可以判断最后一个表达式是否为`...`了。复习一下，在[赋值语句](./ch04-05.table_rw_and_bnf.md#表的写操作和赋值语句)中，读取等号`=`右边的表达式列表时，也需要保留最后一个表达式不加载。这次改造了`exp_list()`函数后，在赋值语句中就也可以使用这个函数了。

其次，如果最后一个实参是`...`，即`ExpDesc::VarArgs`，那么生成新增的`VarArgs`字节码，用以在虚拟机执行时读取全部可变实参，并加载到栈上目标位置。

## VarArgs字节码的虚拟机执行

TODO
