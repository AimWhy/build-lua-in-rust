# 参数

上一节介绍了Lua函数的定义和调用流程。这一节介绍函数的参数。

参数可以分为两个概念：

- 形参，parameter，指函数原型中的参数，包括参数名和参数类型等信息；
- 实参，argument，指函数调用时的参数，是具体的值。

本节后面介绍语法分析和虚拟机执行时，都要明确区分形参和实参。

在Lua语言中，函数的参数就是局部变量！比如对于如下函数：

```lua
local function foo(a, b)
    local x, y = 1, 2
end
```

在执行`foo()`函数时，栈布局如下（栈右边的数字0-3是相对索引）：

```
|     |
+-----+
| foo |
+=====+ <---base
|  a  | 0  \
+-----+     + 参数
|  b  | 1  /
+-----+
|  x  | 2  \
+-----+     + 局部变量
|  y  | 3  /
+-----+
|     |
```

参数和局部变量唯一的区别就是，参数的值是在调用时由调用者传入的，而局部变量是在函数内部赋值的。

## 形参的语法分析

形参的语法分析，也就是函数定义的语法分析。上一节中，函数定义的语法分析省略了参数部分，现在加上。函数定义的BNF是funcbody，其定义如下：

```
   funcbody ::= `(` [parlist] `)` block end
   parlist ::= namelist [`,` `...`] | `...`
   namelist ::= Name {`,` Name}
```

由此可以看到，形参列表由两个可选的部分组成：

- 可选的多个Name，是固定参数。上一节在解析新函数，创建`FuncProto`结构时，局部变量表`locals`字段被初始化为空列表。现在要改为初始化为形参列表。这样形参就在局部变量表的最前面，后续新建的局部变量跟在后面，与本节开头的栈布局图一致。另外，由于Lua语言中调用函数的实参个数允许跟形参个数不等。多则舍去，少则补nil。所以`FuncProto`结果中也要增加形参的个数，用以在虚拟机执行时做比较。

- 最后一个可选的`...`，表明这个函数支持可变参数。如果支持，那么在后续的语法分析中，函数体内就可以使用`...`来引用可变参数，并且在虚拟机执行阶段，也要对可变参数做特殊处理。所以在`FuncProto`中需要增加一个标志位，表明这个函数是否支持可变参数。

综上，一共有三个改造点。在`FuncProto`中增加两个字段：

```rust,ignore
pub struct FuncProto {
    pub has_varargs: bool,  // 是否支持可变参数。语法分析和虚拟机执行中都要使用。
    pub nparam: usize, // 固定参数个数。虚拟机执行中使用。
    pub constants: Vec<Value>,
    pub byte_codes: Vec<ByteCode>,
}
```

另外在初始化`ParseProto`结构时，用形参列表来初始化局部变量`locals`字段。代码如下：

```rust,ignore
impl<'a, R: Read> ParseProto<'a, R> {
    // 新增has_varargs和params两个参数
    fn new(lex: &'a mut Lex<R>, has_varargs: bool, params: Vec<String>) -> Self {
        ParseProto {
            fp: FuncProto {
                has_varargs: has_varargs,  // 是否支持可变参数
                nparam: params.len(),  // 形参个数
                constants: Vec::new(),
                byte_codes: Vec::new(),
            },
            sp: 0,
            locals: params,  // 用形参列表初始化locals字段
            break_blocks: Vec::new(),
            continue_blocks: Vec::new(),
            gotos: Vec::new(),
            labels: Vec::new(),
            lex: lex,
        }
    }
```

至此，完成形参的语法分析。其中涉及到可变参数、虚拟机执行等部分，下面再详细介绍。

## 实参的语法分析

实参的语法分析，也就是函数调用的语法分析。这个在之前章节实现prefixexp的时候已经实现过了：通过`explist()`函数读取参数列表，并依次加载到栈上函数入口的后面位置。与本节开头的栈布局图一致，相当于是给形参赋值。这里解析到实际的参数个数，并写入到字节码`Call`的参数中，用于在虚拟机执行阶段跟形参做比较。

但当时的实现不完整，不支持可变参数。本节后面再详细介绍。

## 虚拟机执行

上面的实参语法分析中，已经把实参加载到栈上，相当于是给形参赋值，所以虚拟机执行函数调用时，本来就无需再处理参数了。但是在Lua语言中，函数调用时实参个数可能不等于形参个数。如果实参多于形参，那无需处理，就认为多出的部分是个占据栈位置但无用的临时变量；但如果实参少于形参，那么需要对不足的部分设置为nil，否则后续字节码对这个形参的引用就会导致Lua的栈访问异常。除此之外，`Call`字节码的执行就不需要对参数做其他处理。

上面语法分析时已经介绍过，形参和实参的个数，分别在`FuncProto`结构中的`nparam`字段和`Call`字节码的关联参数中。所以函数调用的虚拟机执行代码如下：

```rust,ignore
    ByteCode::Call(func, narg) => {  // narg是实际传入的实参个数
        self.base += func as usize + 1;
        match &self.stack[self.base - 1] {
            Value::LuaFunction(f) => {
                let narg = narg as usize;
                let f = f.clone();
                if narg < f.nparam {  // f.nparam是函数定义中的形参个数
                    self.fill_stack(narg, f.nparam - narg);  // 填nil
                }
                self.execute(&f);
            }
```

至此，完成了固定参数的部分，下面介绍可变参数部分。这部分相对而言更加复杂。

## 可变参数

在上面[形参的语法分析](#形参的语法分析)中已经提到了可变参数，其功能比较简单，代表这个函数支持可变参数。本节接下来主要介绍可变参数作为实参的处理，也就是执行函数调用时实际传入的参数。

本节最开始就介绍函数的参数就是局部变量，并画了栈的布局图。不过这个说法只适合固定的实参，而对于可变实参就不适合了。在之前的`foo()`函数中加上可变参数作为示例，代码如下：

```lua
local function foo(a, b, ...)
    local x, y = 1, 2
    print(x, y, ...)
end
```

如果没有可变参数，那么执行时栈布局如下：

```
|     |
+-----+
| foo |
+=====+ <---base
|  a  | 0  \
+-----+     + 固定参数
|  b  | 1  /
+-----+
|  x  | 2  \
+-----+     + 局部变量
|  y  | 3  /
+-----+
|     |
```

现在加上可变参数，栈布局该变成什么样？或者说，可变实参要存在哪里？比如调用函数的语句是`foo(1, 2, 3, 4, 5)`，其中`1`和`2`分别对应形参`a`和`b`，而后面的`3`、`4`和`5`就是可变实参。这三个实参要存在哪里？

```
|     |
+-----+
| foo |
+-----+
|  1  |  \
+-----+   + 固定实参，对应a和b
|  2  |  /
+-----+
|  3  |  \
+-----+   |
|  4  |   + 可变实参，对应...
+-----+   |
|  5  |  /
+-----+
|     |
```

最直接的想法是，存到固定参数的后面。但是，这样是不行的！因为这样就会挤占局部变量的空间，即示例里的`x`和`y`就要后移，后移的距离是可变实参的个数。但是在语法分析阶段是不能确定可变实参的个数的，就无法确定局部变量在栈上的位置，就无法访问局部变量了。

Lua官方的实现是，在语法分析阶段忽略可变参数，让局部变量仍然在固定参数的后面。但是在虚拟机执行时，在进入到函数中后，把可变参数挪到函数入口的前面，并且记录可变实参的个数。这样后续在访问可变参数时，根据函数入口位置和可变实参的个数，就可以定位栈位置，即`stack[self.base - 1 - 实参个数 .. self.base - 1]`。下面是栈布局图：

```
|     |
+-----+
|  3  | -4 \
+-----+     |                          num_varargs: usize  // 记录下可变实参的个数
|  4  | -3  + 相对于上图，                    +-----+
+-----+     | 把可变实参挪到函数入口前面        |  3   |
|  5  | -2 /                                +-----+
+-----+
| foo | <-- 函数入口
+=====+ <-- base
| a=1 | 0  \
+-----+     + 固定实参，对应a和b
| b=2 | 1  /
+-----+
|  x  | 2  \
+-----+     + 局部变量
|  y  | 3  /
```

既然这个方案需要在虚拟机执行时需要记录额外信息（可变实参的个数），并且还要移动栈上参数，那么更简单的做法是直接记录可变实参：

```
|     |
+-----+
| foo | <-- 函数入口                  varargs: Vec<Value>  // 直接记录可变实参
+=====+                                 +-----+-----+-----+
| a=1 | 0  \                            |  3  |  4  |  5  |
+-----+     + 固定实参，对应a和b           +-----+-----+-----+
| b=2 | 1  /
+-----+
|  x  | 2  \
+-----+     + 局部变量
|  y  | 3  /
```

相比于Lua的官方实现，这个方法没有利用栈，而是使用Vec，会有额外的堆上内存分配。但是更加直观清晰。

确定下可变实参的存储方式后，就可以进行语法分析和虚拟机执行了。

## ExpDesc::VarArgs和应用场景

可变实参是一个独立的表达式，在`exp_limit()`函数中解析，并新增一种表达式类型`ExpDesc::VarArgs`，这个类型没有关联参数。读取这个表达式很简单，先检查当前函数是否支持可变参数（函数原型中有没有`...`），然后返回`ExpDesc::VarArgs`即可。具体代码如下：

```rust,ignore
    fn exp_limit(&mut self, limit: i32) -> ExpDesc {
        let mut desc = match self.lex.next() {
            Token::Dots => {
                if !self.fp.has_varargs {  // 检查当前函数是否支持可变参数？
                    panic!("no varargs");
                }
                ExpDesc::VarArgs  // 新增表达式类型
            }
```

但是读到的`ExpDesc::VarArgs`如何处理？这就要先梳理使用可变实参的3种场景：

1. 当`...`作为函数调用的最后一个参数、return语句的最后一个参数、表构造的最后一个列表成员时，代表实际传入的全部实参；

2. 当`...`作为局部变量定义语句、或赋值语句的等号`=`后面最后一个表达式时，会按需求扩展或缩减个数；

3. 其他地方都只代表实际传入的第一个实参。

比如下面的示例代码：

```lua
function foo(a, b, ...)  -- 代表foo()函数支持可变参数
    -- 第2种场景下的2个语句：
    local x, y = ...   -- 取前2个实参
    t.k, t.j = a, ...  -- 取前1个实参

    -- 第3种场景下的若干例子：
    local x, y = ..., b  -- 不是最后一个表达式
    t.k, t.j = ..., b    -- 不是最后一个表达式
    if ... then  -- 条件判断
       t[...] = ... + f  -- 表索引，和二元运算操作数
    end

    -- 第1种场景下的3个语句：
    print("hello: ", ...)  -- 最后一个实参
    local t = {1, 2, ...}  -- 最后一个列表成员
    return a+b, ...  -- 最后一个返回值
end
```

下面对上述3种场景依次分析。

## 场景1：全部可变实参

上述第1种场景中有3个语句：函数调用的最后一个参数、return语句的最后一个参数、表构造的最后一个列表成员。实现思路一样，这里只介绍第一个语句。第二个return语句在后面[小节](TODO)介绍。第三个表构造省略。

本节上面介绍[实参的语法分析](#实参的语法分析)时已经说明是把所有实参通过`explist()`函数依次加载到栈顶，并把实参个数写入到`Call`字节码中。但当时还不支持可变参数，现在加上。

这个场景稍微有一点绕。比如下面的示例：

```lua
function foo(a, b, ...)  -- 形参
    bar(a+b, ...)  -- 实参
end
```

首先第一行`foo()`后面的`...`是形参；第二行`bar()`后面的`...`是实参。这里讨论的是后者。并且，

如果参数列表的最后一个是`...`，即`ExpDesc::VarArgs`，那么实参的个数就无法在语法分析阶段确定，就不能把实参个数写入到`Call`字节码中。这就需要一个特殊值来代表可变参数的情况。然后在虚拟机执行期间，对于这种可变参数的情况，根据栈的情况来读取实际的实参个数。

先看语法分析阶段的处理，再看虚拟机执行阶段。语法分析时，参考官方Lua的实现，选择`0`来代表这种可变参数的情况，而对于固定实参的情况，就把实参个数加上1再写入到`Call`字节码中。比如没有实参就写`1`，有3个实参就写`4`。具体代码如下：

```rust,ignore
    fn args(&mut self) -> ExpDesc {
        let ifunc = self.sp - 1;
        let narg = match self.lex.next() {
            Token::ParL => {
                if self.lex.peek() != &Token::ParR {
                    // 读取实参列表。只保留和返回最后一个实参last_exp，而把前面的实参
                    // 依次加载到栈上并返回其个数nexp。
                    let (nexp, last_exp) = self.explist();

                    self.lex.expect(Token::ParR);

                    if last_exp == ExpDesc::VarArgs {
                        // 可变实参。生成新增的VarArgs字节码，读取全部可变实参！！
                        self.fp.byte_codes.push(ByteCode::VarArgs(self.sp as u8));
                        None
                    } else {  // 固定实参
                        self.discharge(self.sp, desc);
                        Some(nexp + 1)
                    }
                } else {  // 没有参数
                    self.lex.next();
                    Some(0)
                }
            }
            Token::CurlyL => {  // 不带括号的表构造
                self.table_constructor();
                Some(1)
            }
            Token::String(s) => {  // 不带括号的字符串常量
                self.discharge(ifunc+1, ExpDesc::String(s));
                Some(1)
            }
            t => panic!("invalid args {t:?}"),
        };

        // 对于n个固定实参，转换为n+1；
        // 对于可变实参，转换为0。
        let narg_plus = if let Some(n) = narg { n + 1 } else { 0 };

        ExpDesc::Call(ifunc, narg_plus)
    }
```

上述代码有几个地方需要说明。首先`explist()`方法，原来的行为是把所有表达式列表都加载到栈上，现在修改为保留并返回最后一个表达式，而只把前面的表达式加载到栈上。这样就可以判断最后一个表达式是否为`...`了。复习一下，在[赋值语句](./ch04-05.table_rw_and_bnf.md#表的写操作和赋值语句)中，读取等号`=`右边的表达式列表时，也需要保留最后一个表达式不加载。这次改造了`exp_list()`函数后，在赋值语句中就也可以使用这个函数了。

其次，如果最后一个实参是`...`，即`ExpDesc::VarArgs`，那么生成新增的`VarArgs`字节码，用以在虚拟机执行时读取全部可变实参，并加载到栈上目标位置。

## VarArgs字节码的虚拟机执行

TODO
